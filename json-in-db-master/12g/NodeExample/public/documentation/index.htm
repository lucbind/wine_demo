<!doctype html>
<!--
/* ================================================  
 *    
 * Copyright (c) 2016 Oracle and/or its affiliates.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ================================================
 */
-->
<html>
<head>
 <style>
    ol .subNumberedList {counter-reset: item}
    li .subNumberedList {display: block}
    li:before .subNumberedList { content: counters(item, ".") " "; counter-increment: item }
 </style>
 <style>
    ol .subNumberedList {counter-reset: item}
    li .subNumberedList {display: block}
    li:before .subNumberedList { content: counters(item, ".") " "; counter-increment: item }
 </style>
    <link rel="stylesheet" href="jsonViewer.css" type="text/css">
    <link rel="stylesheet" href="/frameworks/bootstrap/dist/css/bootstrap.min.css">
	<!-- Optional theme -->
	<link rel="stylesheet" href="/frameworks/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="agate.css">
</head>
<body onLoad="renderSampleDocuments()" style="padding: 15px">
<div>
  <h1>Oracle Movie Ticketing Application (NODE.js with Soda for REST).</h1>
  <p>This application demonstrates how to develop an application that combines document centric application development techniques, JSON based data persistence, REST Services with an Oracle Database. The application is a simulation of a system for searching movies and theaters and then purchasing tickets to see a given showing of a movie. It is a single-page web application, built using a decoupled AngularJS front-end that communicates with a set of REST services provided by an application tier developed in Node.js. The application tier uses REST to invoke micro-services provided by Oracle's SODA for REST, a component of Oracle Rest Data Services (ORDS). Soda for rest provides data persistence services for JSON and other kinds of document. The application provides the following capabilities:</p>
  <ol>
    <li>List theaters: Shows the available theaters. Users may drill down to a list of movies showing at the theater by clicking on the "Movies" button associated with a given theater. 
        <br><br>
        <img src="ListTheaters.png" alt="List Theaters" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>List movies: Shows the available movies. Users may drill down to a list of the theaters showing a particular movie by clicking on the "Theaters" button associated with a movie.
        <br><br>
        <img src="ListMovies.png" alt="List Movies" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>Search theater by name, city and zip.
        <br><br>
        <img src="SearchTheaters.png" alt="Search Theaters" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>Search theaters by proximity to current location.
        <br><br>
        <img src="SearchTheatersSpatial.png" alt="Search Theaters Spatial" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>Search movies by title and plot.
        <br><br>
        <img src="SearchMovies.png" alt="Search Movies" style="width: 400px; height:  auto">
        <br><br>
     </li>
    <li>Show the movies playing at a particular theater on a given date. Users can book a ticket to a particular screening by clicking on the show time.
        <br><br>
        <img src="MoviesByTheater.png" alt="Movies by Theater" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>Show the theaters showing a particular movie on a given date. Users can book a ticket to a particular screening by clicking on the show time.
        <br><br>
        <img src="TheatersByMovie.png" alt="Theaters by Movie" style="width: 400px; height:  auto">
        <br><br>
    </li>
    <li>Purchase tickets to see a particular showing of a movie at a particular theater.
        <br><br>
        <img src="BookTickets.png" alt="Book Tickets" style="width: 400px; height:  auto">
        <br><br>
    </li>
  </ol>
  <h2>Architecture</h2>
  <p>The architecture for this version of the application is as follows: </p>
  <p><img src="MovieTicketingArchitecture.png" style="width: 400px; height:  auto" alt="Movie Ticketing Architecture"/></p>
  <p>The front end application uses HTML5 and Angular to communicate with an application-tier developed using
    JavaScript and Node.js. The application tier makes use of a number of standard node modules, including express and http. The Application tier uses SODA for REST and Oracle REST
    Data Services (ORDS) to communicate with the back-end data store. The back-end data store is an Oracle 12c Database.</p>
  <h2>Data Model</h2>
  <p>The data model for the application is shown in the following diagram:</p>
  <p><p>&nbsp;</p>
  <img src="MovieTicketingDataModel.png" style="width: 400px; height:  auto" alt="Movie Ticketing Data Model"><br>
  It consists of four collections, Movie, Theater, Screening and TicketSale that are used to manage the JSON document types that represent the objects used by the application. The 5<sup>th</sup> collection, Poster, contains Binary Content (Images). Each of the collections has a unique, system generated primary key. Many of the object types also contain an application supplied unique id as part of the object type.</p>
  <ul>
    <li><strong>Theater</strong>: contains information about a Theater, including a unique id, its location and default information about the number and capacity of its auditoriums. Click the right arrow below to see an sample theater document:<br>
      <br>
      <div>
	       <div id="sampleTheater"></div>
    	</div>
      <br>
    </li>
    <li><strong>Movie</strong>: contains information about a Movie, including a unique id, title, plot, and cast and crew information. Click the right arrow below to see an sample movie document:<br>
      <br>
      <div>
			<div id="sampleMovie"></div>
       	</div>
       	<br>
    </li>
    <li><strong>Screening</strong>: Details movie showings by theater, screen, start time, ticket pricing for the show and number of seats remaining.&nbsp; Click the right arrow below to see an sample screening document:<br>
      <br>
      <div>
    		<div id="sampleScreening"></div>
		</div>
        <br>
	</li>
    <li><strong>TicketSale</strong>: Contains details of seat purchases. Click the right arrow below to see an sample ticket sale document:<br>
      <br>
      <div>
		    <div id="sampleTicketSale"></div>
		</div>
		<br>
    </li>
    <li><strong>Poster</strong>: Contains binary images of the posters for the movies.</li>
  </ul>
  <h2>Client Tier</h2>
    <p>The front end application consists of a single page HTML file named index.html. This file is served up by the Node.js server. The front end application logic, including the AngularJS modules, controllers and factories that invoke the REST services provided by Node.js server are contained in the file movieticketing.js file. The user interface uses the Twitter Bootstrap framework to provide a simple, clean and modern user interface.</p>
  <h2>Application Tier (Node.js)</h2>
    <p>The JavaScript code that makes up the application tier is organized into 3 layers.</p>
  <ol>
    <li><strong>movie_ticketing.js</strong>: This  module contains the application logic that provides the REST services exposed to the browser based componentry. Some of these services are nothing more that very thin  veneers over the underlying collections. Others perform quite complex processing that requires multiple interactions between the application code and the Document Store.<br><br></li>
    <li><strong>movie_ticket_api.js</strong>: This module provides a pre-packaged set of operations for each of the Document Types used by the Movie Ticketing application. It is a very thin veneer on top of 
	docStore_api.js and soda_rest_api.js that provides collection specific 
	implementations of the functionality exposed the underlying modules. This layer is also responsible for managing the collection properties that provide the definition of each of the document collections and indexes used by the application. This information is maintained in the<strong> 
	file MovieTicketing.collectionMetadata.soda.json.</strong> All operations on collections are routed through this layer.<br><br></li>
    <li><strong>docStore_api.js:</strong> This module provides set of helper 
	functions related to error reporting and logging as well as an abstraction layer 
	over the the SODA for REST operations. This enables a clean separation between 
	SODA for REST and MovieTicketing specific application logic. The primary purpose of this layer is to 
	facilitate swapping out the SODA for REST interface for a native SODA for 
	Node.js interface should 
	one be come available at some point. It also enables the logging and tracing 
	layer, provided by docStore_trace_api.js to be injected into the application 
	in clean manner, by specifying the keyword TRACE as the last command line 
	argument supplied to Node.js when starting the application. Currently docStore_api.js 
	it totally reliant on the functionality provided by module soda_rest_api.js 
	to communicate with the underlying document store. <br></li>
	  <li><strong>soda_rest_api.js</strong>: This module provides a generic handler for the mechanics of 
	  performing SODA for REST operations via the NPM package&nbsp; requst-promise-native. This includes setting up the 
	  options object, marshaling any content or arguments that are required to 
	  make the request and processing the response. This module has no pre-determined knowledge of the collections it is interacting with; 
	  both it is and docStore_api.js are designed to be re-used by any Node.js application that wants to make use of SODA for REST. It 
	  exports a set of functions that expose each of the micro-services provided by the SODA for REST API. Each of the functions return a JavaScript Promise 
	  that is intended for use with asynchronous functions use JavaScripts "async/await" functionality 
	  supported by Node 8. This enables the development of applications where all interaction with the database is performed asynchronously.<br>
	  <br></li>
  </ol>
<h2>Invoking SODA for REST from Node.js</h2>
<p>All interaction between the application and the JSON document store managed 
by the Oracle Database goes through module soda_rest_api.js. This module 
soda_rest_api.js the NPM package request-promise-native to perform the HTTP 
requests required to invoke SODA for REST. The request package uses an options 
object to specify the details of the HTTP operation to be performed. All of the 
functions in soda_rest_api.js module follow a similar design pattern, they 
construct the appropriate options object for the operation in question and tpass 
the options object to&nbsp; a common function, send Request() which uses the 
request package to make the HTTP request. Function sendRequest() uses the 
JavaScript await operator, implemented as part of Node 8, to invoke the promise 
used to manages the&nbsp; HTTP operation. The await operator makes it easy to 
implement asynchronous HTTP opertions , ensuring optimal recourse usage on the 
Node.js server. Function sendRequest() is shown below:</p>
<div style="padding-left: 50px;"><pre><code>async function sendRequest(options) {

  try { 
    const response = await request(options).auth(getUsername(), gePassword(), true);
  } catch (e) {
    throw processError(moduleId,logContainer.logRequest,e);
  } 
}</code></pre>
</div>
  <p>In addition to the modules listed above the application includes the following additional modules:</p>
  <ul>
    <li> <strong>index.js</strong> and <strong>routes.js</strong>: These classes use the popular Express.js framework to handle the incoming request from the client tier and routing them to the appropriate functions exposed by movie_ticketing.js.</li>
    <li><strong>config.js</strong>: This class manages the connection information required by the application tier in order to talk to ORDS.</li>
    <li><strong>external_interfaces.js</strong>: This class provides a set of services that are used to load test data from external data sources (Fandango.com and TheMovieDatabase.org). </li>
  </ul>
  <p>    There are 3 configuration files that are used by the application:</p>
  <ul>
    <li><strong> MovieTicketing.connectionProperties.soda.json</strong>: This file contains the information required to establish a connection between the Node.js layer and the ORDS layer.</li>
    <li><strong> MovieTicketing.collectionMetadata.soda.json</strong>: This file contains the CollectionProperties and Index definitions for the document collections used by the application</li>
    <li><strong>dataSources.json</strong>: This file provides the connection information for the external websites that are used as a source of test data. </li>
  </ul>
  <p>The MovieTicketing application exposes the following Rest services which are consumed by the browser-based front end.</p>
  <ol>
    <li><strong>ListTheaters</strong>: List all Theaters</li>
    <li><strong>GetTheater</strong>: Get a Theater based on its key</li>
    <li><strong>GetTheaterById</strong>: Get a Theater based on its Id.</li>
    <li><strong>GetMoviesByTheater</strong>: Get the Movies showing in a Theater on a given date</li>
    <li><strong>SearchTheaters</strong>: Search Theaters based on name, city and zip.</li>
    <li><strong>ListMovies</strong>: List all Movies</li>
    <li><strong>ListMoviesByReleaseDate</strong>: List all Movies, ordered by Release Date</li>
    <li><strong>GetMovie</strong>: Get a Movie based on its key</li>
    <li><strong>GetMovieById</strong>: Get a Movie based on its Id.</li>
    <li><strong>GetTheatersByMovie</strong>: Get the set of Theaters showing a Movie on a given date</li>
    <li><strong>SearchMovies</strong>: Search Movies based on Title and Plot</li>
    <li><strong>BookTicket</strong>: Book one or more tickets to see a given movie</li>
  </ol>
  <p>Some of these services are nothing more that very thin veneers over the underlying collections. Other provide quite extensive processing, requiring multiple interactions between the Application Tier and the Document Management layer. </p>
</div>
<h1>Overview</h1>
<p>When the application is launched the user is presented with 3 tabs, "List Theaters", "List Movies" and "Load Test Data."</p>
    <ul>
        <li><strong>List Theaters: </strong>shows information about theaters. The information for each theater is stored as JSON documents in the THEATER collection. There is a "Movies" button associated with each theater Clicking the button will open an additional tab that displays information about the movies that are being screened at the theater on the specified date. Customers can purchase tickets to a particularscreening from this tab.</li>
        <li><strong>List Movies: </strong>shows information about movies. The information about each movie is stored as JSON documents in the Movie collection. These is a "Theaters" button associated with each movie  Clicking the button will open an additional tab that display information about the theaters that are screening that movie on the specified date. Customers can purchase tickets to a particularscreening from this tab.</li>
        <li><strong>Load Test Data: </strong>Provides access to services that populate the Movie Ticketing document store</li>
    </ul>

 <p>The following sections will examine the code behind some of these services and also look at how they are consumed in by the Browser-based component. 
 Note that the code samples shown below are simplifciations of the actual 
 application code.</p>
<h1>List Theaters Service</h1>
<p>The List Theaters tab is based on the output generated by the rest service associated with a GET operation on the end point /movieticket/theaters. The AngularJS controller used to invoke this service is shown below</p>
   
<div style="padding-left: 50px;">
<pre><code class="javascript">app.controller('theatersCtrl',function($scope, $http, $cookies, theaterService) {

  $cookies.put('movieTicketGUID', GUID)

  $scope.theaterService = theaterService;

  $http({
    method: 'GET',
    url: '/movieticket/theaters/',
  }).success(function(data, status, headers) {
    $scope.theaterService.theaters = data;
    var path = '/movieticket/movieticketlog/operationId/'+ headers('X-SODA-LOG-TOKEN')
    $http.get(path).success(function(data, status, headers) {
      $scope.theaterService.logRecord = data
      // console.log(JSON.stringify($scope.theaterService.logRecord));
    });
  });
      				
});
</code></pre></div>

<p>A snippet of HTML and AngularJS code that is used to render the output of the service as HTML is shown below:</p>

<div style="padding-left: 50px;"><pre><code id="theaterServiceHTML" class="html">
</code></pre></div>

<p>When a GET operation is performed on the URL /movieticket/theaters the Node.js application invokes the function theatersService provided by the module movie_ticketing.api. This function is declared as 'async', allowing it to use the 'await' operator to perform asynchronous execution of the promise returned by function 'getTheaters()' defined in the module 'movie_ticket_api.js'. The code for this module is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticketing.js</strong></p>
<pre><code class="javascript">async function theatersService(sessionState, response, next) {

 try {
   const httpResponse = await movieAPI.getTheater(sessionState, key)
   writeResponse(response,httpResponse.json,sessionState.operationId);
 } catch (e) {
   next(e);
  }

}</code></pre>
</div>
<p>This function uses the SODA for REST "Get Collection" micro-service to return 
the required list of Theater documents. It invokes function getTheaters() in module movie_ticket_api.js. 
The resulting JSON is retuned to the client as the response. Function 
theatersService() also adds an X-SODA-LOG-TOKEN header to the response that provides the client application with a unique identifier that can be used to retrieve the log records associated with the operation. 
<h2>Listing the contents of a collection</h2>
<p>Function getTheaters() is a veneer over function getCollection() exported by module docStore_api.js 
which in turn calls function getCollection() exported by module 
soda_rest_api.js. The SODA for REST calls required to list&nbsp; the contents of the collection are implemented by function getCollection() in the module soda_rest_api.js. 
Function getCollection() relies on function processQuery() to execute the HTTP request and manage the automatic pagination of the results, 
since SODA for REST operations are limited to returning a maximum of 1000 documents per HTTP request.
The code for these functions is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">function getTheaters(limit,fields) {
  
   return docStoreAPI.getCollection('Theater',limit,fields)
     
}</code></pre>
<p><strong>docStore_api.js</strong></p>
<pre><code class="javascript">async function getCollection(collectionName, limit, fields, includeTotal) {

  return dbAPI.getCollection(collectionName, limit, fields, includeTotal)

}</code></pre>
<p><strong>soda_rest_api.js</strong></p>
<pre><code>async function processQuery(options, limit) {

  const results = await sendRequest(options);

  if ((limit !== 'unlimited') &amp;&amp; (limit === 0)) {
    results.body.items = []
    results.body.count = 0
  }
  else {
    if ((limit === 'unlimited') || (results.body.count &lt; limit)) {
      while (results.body.hasMore) {
        if (limit !== 'unlimited') {
          options.qs.limit = limit - results.body.count
        }
        options.qs.offset = results.body.count
        const moreResults = await sendRequest(moduleId, sessionState, options, logContainer);
        results.body.items = results.body.items.concat(moreResults.body.items);
        results.body.count = results.body.items.length
        results.body.hasMore = moreResults.body.hasMore
        if (results.body.count === limit) {
          break;
        }
      }
    } 
  }
}

async function getCollection(collectionName, limit, fields, includeTotal) {

  const options = { method : 'GET'
                  , baseUrl : documentStoreURL
                  , uri : getCollectionLink(collectionName)
                  , qs : getLimitAndFields({}, sodaLimit, fields, includeTotal)
                  , headers : setHeaders()
                  , time : true
                  , json : true
                  };

  return processQuery(options,limit)
}</code></pre>
<p>A "Get Collection" operation is executed by performing a GET operation on the URL associated with the collection</p>
</div>       
<h1>List Movies By Theater Service</h1>
<p>The "List Movies by Theater" tab is opened when the user clicks on the "Movies" button associated with one of the theaters on the "List Theaters" tab. 
It lists the show times for the movies playing at the selected theater on the specified date. 
The content of this tab is based on the output generated by the rest service associated with a GET operation on the end point /theaters/:id/movies/:date, where :id is the id of the theater and :date is the required date. 
When a GET operation is performed on the URL the Node.js application invokes the function moviesByTheaterService() 
exported by the module movie_ticketing.api passing the values for id and date. The code for this module is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticketing.js</strong></p>
<pre><code class="javascript">async function moviesByTheaterService(sessionState, response, next, id, dateStr) {

  try {
    const httpResponse = await movieAPI.getTheater(sessionState, id)
    const theater = httpResponse.json;
    delete(theater.screens);    

    const moviesByTheater = await getMoviesByTheaterAndDate(sessionState,theater,dateStr)
	writeResponse(response,moviesByTheater,sessionState.operationId);
  } catch (e){
    next(e);
  };
} </code></pre>
</div>
<p>This function invokes function getTheater() exported by the module movie_ticket_api.js to get the information for the specified theater using its internal key. 
It then calls function getMoviesByTheaterAndDate() to construct a JSON document that summarizes the movies and show times for the specified theater and date. 
The resulting JSON forms the response to the request. 
The code for function getMoviesByTheaterAndDate() is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">async function getMoviesByTheaterAndDate(sessionState,theater, date) {

  var moviesByTheater = { 
    'theater' : theater,
    'movies' : []
  };
  
  var startDate = new Date(Date.parse(date))
  startDate.setHours(0);
  startDate.setMinutes(0);
  startDate.setSeconds(0);
  startDate.setMilliseconds(0);
  
  var endDate = new Date(Date.parse(date));
  endDate.setHours(0)
  endDate.setMinutes(0)
  endDate.setSeconds(0)
  endDate.setMilliseconds(0);
  endDate.setDate(endDate.getDate() + 1);
  
  var qbe = { theaterId : theater.id, startTime : { "$gte" : startDate, "$lt" : endDate }, "$orderby" : { screenId : 1, startTime : 1}};
  
  const httpResponse = await  movieAPI.queryScreenings(sessionState, qbe, 'unlimited')
  let movies = await processScreeningsByTheaterAndDate(sessionState,httpResponse)
  moviesByTheater.movies = movies;
  return moviesByTheater;

}</code></pre></div>
<p>This function uses the SODA for REST "Query By Example (QBE)" micro-service to&nbsp; 
to search for the required screening documents. First it constructs a QBE 
document that specifies the required theater and date range. Then it invokes function queryScreenings() in module movie_ticket_api.js 
to execute the QBE and fetch the required screening documents from the document 
store. These documents are then passed to function processScreeningsByTheaterAndDate() in order to generate the required summary. 
Function processScreeningsByTheaterAndDate() uses a second QBE to fetch the details of each movie being shown. 
The resulting JSON is retuned to the client as the response.<h2>Searching for documents in 
a collection</h2>
<p>Function queryScreenings() is a veneer over function queryByExample() exported by module docStore_api.js 
which in turn calls function queryByExample() exported by module 
soda_rest_api.js. The SODA for REST calls required to perform the search of the 
collection are implemented by function queryByExample() in the module soda_rest_api.js. 
Function queryByExample() also relies on function processQuery() to execute the 
HTTP request and manage the automatic pagination of the results.
The code for these functions is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">function queryScreenings(sessionState, qbe, limit, fields, includeTotal) {
	
	return docStoreAPI.queryByExample(sessionState, 'Screening', qbe, limit, fields, includeTotal);

}</code></pre>
<p><strong>docStore_api.js</strong></p>
<pre><code class="javascript">async function queryByExample(sessionState, collectionName, qbe, limit, fields, includeTotal) {

  return dbAPI.queryByExample(sessionState, collectionName, qbe, limit, fields, includeTotal)
  
}</code></pre>
<p><strong>soda_rest_api.js</strong></p>
<pre><code>async function queryByExample(sessionState, collectionName, qbe, limit, fields, includeTotal) {

  const options = { method  : 'POST'
                  , baseUrl : documentStoreURL
                  , uri     : getCollectionLink(collectionName)
                  , qs      : getLimitAndFields({action : "query"}, limit, fields, includeTotal)
                  , json    : qbe
                  , time    : true
                  };

  return processQuery(sessionState,options,limit)
}</code></pre>
<p>A "Query By Example" operation is executed by performing a POST operation on the URL associted with collection, specifying the query string 'action=query'. The QBE specification is supplied as the body of the POST. </p>
</div>
<h1>Purchase Tickets Service</h1>
<p>Both the List Movies By Theater and List Theaters by Movie tab allow the user to purchase tickets to see a movie by clicking on the showing they would like to attend. 
Once they have entered the number of tickets they require they can complete the purchase by clicking on the '$' icon. 
The purchase is made by performing a POST operation on the URL /movieticket/bookTickets. When a POST operation is performed on this URL the Node.js application invokes the function bookTicketService() provided by the module movie_ticketing.api. 
The information about the number of tickets required is provided as the body of the POST operation. The code for this module is shown below:</p>
<p>Function bookTicketService() invokes function bookTickets() exported by the module movie_ticketing.api to record the ticket sale. This functions returns a simple JSON document that indicates whether or not the booking was successful. This document is returned to the front end. </p>
<p>Function bookTickets() uses the SODA for REST "Update Document" and "Insert 
Document" micro-services to record the transaction. First it invokes function 
updateScreening() exported by module movie_ticket_api.js to update the screening 
document with a new version of the document containing the new value for the 
number of seats remaining for the screening. Then it invokes function 
insertTicketSale() expotred by module movie_ticket_api.js to store the document 
that records the ticket sale. </p>
<p>SODA for REST uses an optimistic locking strategy to prevent conflicting updates from taking place. This follows REST conventions and is based on the value of the documents ETag. Any time an application might need to update a document it must fetch the document metadata as well as document content in order to get the current value of the ETag. Conflicting updates are prevented by adding an "If Match" header to the HTTP request. The value of this header is the ETag that was obtained last time the document was read. If there has been a conflicting update the current ETag for the document will not match the ETag supplied by the application and the PUT operation will return HTTP Status code of 412 [Precondition Failed] indicating that the PUT operation was not successful. If there are no conflicting updates then the PUT operation will return HTTP Status code 200 [Successful].&nbsp; </p>
<div class="subNumberedList">
<p>The application logic for completing the booking is as follows:</p>
 <style>
    ol .subNumberedList {counter-reset: item}
    li .subNumberedList {display: block}
    li:before .subNumberedList { content: counters(item, ".") " "; counter-increment: item }
 </style>
 <div class="subNumberedList">
 <ol>
   <li>Calculate the total number of seats required.</li>
   <li>Get the latest version of the specified screening document using its internal key. Retrieve the document and the associated metadata.</li>
   <li>Check the number of seats remaining for the required screening
     <ol>
       <li>Insufficient seats remain to fulfill the request:
         <ol>
           <li>Return a 'Sold Out' message</li>
         </ol>
        </li>
        <li>Sufficient seats remain to fulfill the request:
           <ol>
              <li>Decrement the seats count for the screening and complete the booking process</li>
              <li>Update the Screening document using the updateScreening method provided by the movie_ticket_api.js module.</li>
              <li>Check the status of the HTTP request
                  <ol>
                      <li>Status 200: Successful update
                          <ol>
                             <li>Construct the Ticket Sale document</li>
                             <li>Insert the ticketSale document into the document using the insertTicketSale method provided by the movie_ticket_api.js module.</li>
                             <li>Return a 'Booking Successful' message</li>
                          </ol>
                      </li>
                      <li>Status 412 : There has been a conflicting update
                          <ol>
                             <li>Repeat this process</li>
                          </ol>
                      </li>
                  </ol>
              </li>
          </ol>
        </li>
    </ol>
  </li>
</ol>
</div>
	<p>The code for these functions is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">async function bookTicketService(sessionState, response, next, bookingRequest) {

  try {
    let bookingStatus = await bookTickets(sessionState, bookingRequest)
	writeResponse(response,bookingStatus,sessionState.operationId);
  } catch (err) {
    next(err);
  };
 
}

async function bookTickets(sessionState, bookingRequest) {

  var key           = bookingRequest.key;
  var etag          = null;
  var screening     = {}
  var seatsRequired = bookingRequest.adult + bookingRequest.senior + bookingRequest.child;
  
  try {
    let httpResponse = await movieAPI.getScreening(sessionState, key)
    etag = httpResponse.etag;
    screening = httpResponse.json;

    if (screening.seatsRemaining &lt; seatsRequired) {
      return {
        status : "SoldOut", 
        message : `Only ${screening.seatsRemaining} seats are available for this performance.`
      };
    }
    else {
      screening.seatsRemaining = screening.seatsRemaining - seatsRequired;
      try {
        httpResponse = await movieAPI.updateScreening(sessionState, key, screening, etag)
        switch (httpResponse.status) {
          case constants.SUCCESS: // Seat Reserved : Record Ticket Sale
            var ticketSale = makeTicketSale(bookingRequest, screening);
            try {
              httpResponse = await movieAPI.insertTicketSale(sessionState, ticketSale)
              switch (httpResponse.status) {
                case constants.CREATED: // Booking Completed
                  return { 
                    status  : "Booked",
                    message : "Please enjoy your movie."
                  }
                default:
                  throw httpResponse;
              }
            } catch (err) {
              throw err;     
            }
          default:
            throw httpResponse;
        }
      } catch (err) {
        switch (err.status) {
          case constants.CONFLICTING_UPDATE: // Conflicting Ticket Sales : Try again
            return bookTickets(sessionState,bookingRequest) 
          default:
            throw err;
        }
      }
    }
  } catch (err) {
    console.log(err)
    throw err;     
  }
}</code></pre>
	</div>
</div>
<h2>Updating a document in a collection</h2>
<p>Function updateScreening() is a veneer over function&nbsp; putJSON()&nbsp; 
exported by module docStore_api.js. Function putJSON() calls function 
putDocument(), specifying that the content-type for the document is 
"application/json". Function putDocument() in-turn calls function putDocument() exported by module 
soda_rest_api.js. The SODA for REST calls required to update the document are implemented by function 
putDocument() in the module soda_rest_api.js. The code for these functions is shown below:</p>
<div style="padding-left: 50px;">
	<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">function updateScreening(sessionState, key,screening,etag) {
	
	return docStoreAPI.putJSON(sessionState, 'Screening',key,screening,etag);

}</code></pre>
<p><strong>docStore_api.js</strong></p>
<pre><code class="javascript">function putJSON(sessionState, collectionName, key, json, etag) {

  return putDocument(sessionState, collectionName, key, json, 'application/json', etag);

}

async function putDocument(sessionState, collectionName, key, document, contentType, etag) {

  return dbAPI.putDocument(sessionState, collectionName, key, document, contentType, etag)
  
}  </code></pre>
<p><strong>soda_rest_api.js</strong></p>
<pre><code>async function putDocument(sessionState, collectionName, key, document, contentType, etag) {

  const options = { method  : 'PUT'
                  , baseUrl : documentStoreURL
                  , uri     : getDocumentLink(collectionName,key)
                  , headers : setHeaders(contentType , etag)
                  , time    : true
                  };

  if (contentType === 'application/json') {
    options.json = document
  }
  else {
    options.body = document
  }

  const results = await sendRequest(options);
  return results 
}</code></pre><p>An "Update Document" operation is executed by performing a PUT on a particular document within the target collection. The document is identified using the ID that was assigned or provided when the document was inserted.
The updated content is supplied as the body of the PUT. When using package request-promise-native, a JSON payload is passed using the key 'json', a non-JSON payload is passed using the key 'body'.</p>
</div>
<p</p>

<h2>Adding a document to a collection</h2>
<p>Function insertTicketSale() is a veneer over function&nbsp; postJSON()&nbsp; 
exported by module docStore_api.js. Function postJSON() calls function 
postDocument(), specifying that the content-type for the document is 
"application/json". Function postDocument() in-turn calls function postDocument() exported by module 
soda_rest_api.js. The SODA for REST calls required to insert the document are implemented by function 
postDocument() in the module soda_rest_api.js. The code for these functions is shown below:</p>
<div style="padding-left: 50px;">
<p><strong>movie_ticket_api.js</strong></p>
<pre><code class="javascript">function insertTicketSale(sessionState, ticketSale) {
	
	return docStoreAPI.ensurePostJSON(sessionState, 'TicketSale', ticketSale);

}</code></pre>
<p><strong>docStore_api.js</strong></p>
<pre><code class="javascript">function postJSON(sessionState, collectionName, json) {

  return postDocument(sessionState, collectionName, json, 'application/json');

}

async function postDocument(sessionState, collectionName, document, contentType) {

  return dbAPI.postDocument(sessionState, collectionName, document, contentType)

}</code></pre>
<p><strong>soda_rest_api.js</strong></p>
<pre><code>async function postDocument(sessionState, collectionName, document, contentType) {
  
  const options = { method  : 'POST'
                  , baseUrl : documentStoreURL
                  , uri     : getCollectionLink(collectionName)
                  , headers : setHeaders(contentType , undefined)
                  , time    : true
                  };

  if (contentType === 'application/json') {
    options.json = document
  }
  else {
    options.body = document
  }

  const results = await sendRequest(moduleId, sessionState, options, logContainer);
}</code></pre>
<p>An "Insert Document" operation is executed by performing a POST on the target collection. 
The content of the new document is supplied as the body of the POST. When using package request-promise-native, a JSON payload is passed using the key 'json', a non-JSON payload is passed using the key 'body'.</p>
</div>
<h1>Installation and Configuration</h1>
<p>These instructions assume you already have access to an Oracle Database 12.1.0.2.0 instance with Bundle Patch 13 installed. If you do not have this available you can start by downloading the latest version of the <a href="http://www.oracle.com/technetwork/database/enterprise-edition/databaseappdev-vm-161299.html">Oracle Developer Days VM </a> from the Oracle Technology Network. Although this VM comes with a version of Oracle Rest Data Services installed, you will need to update it from 3.0.4 to 3.0.5 by following step 1 of the instructions below </p>
    <br>
        <p>The MovieTicketing demonstration works with sample data downloaded from publically available websites. The THEATER collection is populated with data obtained from an RSS feed published by Fandango.com. Optionally, this data can be enriched with location information obtained from a geocoding service, such as the one provided by Google. The Movie and Poster collections are populated using data obtained from the website themoviedatabase.org  (TMDb). In order to obtain data from TMDb and Google you must register with those sites and obtain an API key.</p>
<h2>1. Obtain API keys for TMDb and Google.</h2>
<ol>
    <li>Register for a Google Geocoding API key by following the instructions found <a href="https://developers.google.com/maps/documentation/javascript/get-api-key">here</a>.</li>
    <li>Make a note of your Google API key.</li>
    <li>Register for a themoviedatabase.org (TMDb) account by following the instructiosn found <a href="https://www.themoviedb.org/account/signup?language=en">here</a>.</li>
    <li>Sign in to your account, click the API link in their left hand menu and follow the instructions to request an API key.</li>
    <li>Make a note of your TMDb API key.</li>
</ol>
<h2>2. Install and Configure Node.js</h2>
<ol>
    <li>Download <a href="https://nodejs.org/en/download/">Node.js</a> from nodejs.org<br><br></li>
    <li>Install Node.js<br><br>
        <p>The following commands will work on Enterprise Linux, assuming your are running as root, for other environments please refer to the platform specific platform specific installation instructions at <a href="https://docs.npmjs.com/getting-started/installing-node">https://docs.npmjs.com/getting-started/installing-node</a>.</p>
        <pre><code>
[root@localhost oracle]# curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -
## Installing the NodeSource Node.js 8.x repo...


## Inspecting system...

+ rpm -q --whatprovides redhat-release || rpm -q --whatprovides centos-release || rpm -q --whatprovides cloudlinux-release || rpm -q --whatprovides sl-release
+ uname -m

## Confirming "el7-x86_64" is supported...

+ curl -sLf -o /dev/null 'https://rpm.nodesource.com/pub_8.x/el/7/x86_64/nodesource-release-el7-1.noarch.rpm'

## Downloading release setup RPM...

+ mktemp
+ curl -sL -o '/tmp/tmp.XATaz89OU3' 'https://rpm.nodesource.com/pub_8.x/el/7/x86_64/nodesource-release-el7-1.noarch.rpm'

## Installing release setup RPM...

+ rpm -i --nosignature --force '/tmp/tmp.XATaz89OU3'

## Cleaning up...

+ rm -f '/tmp/tmp.XATaz89OU3'

## Checking for existing installations...

+ rpm -qa 'node|npm' | grep -v nodesource

## Run `yum install -y nodejs` (as root) to install Node.js 8.x and npm.
## You may also need development tools to build native addons:
##   `yum install -y gcc-c++ make`

[root@localhost oracle]# yum install -y nodejs
Loaded plugins: langpacks, ulninfo
nodesource                                                 | 2.5 kB   00:00     
nodesource/x86_64/primary_db                               |  30 kB   00:00     
Resolving Dependencies
--> Running transaction check
---> Package nodejs.x86_64 2:8.9.4-1nodesource will be installed
--> Finished Dependency Resolution

Dependencies Resolved

=======================================================================================================================================
 Package                    Arch                       Version                                    Repository                      Size
=======================================================================================================================================
Installing:
 nodejs                     x86_64                     2:8.9.4-1nodesource                        nodesource                      17 M

Transaction Summary
=======================================================================================================================================
Install  1 Package

Total download size: 17 M
Installed size: 51 M
Downloading packages:
warning: /var/cache/yum/x86_64/7Server/nodesource/packages/nodejs-8.9.4-1nodesource.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 34fa74dd: NOKEY
Public key for nodejs-8.9.4-1nodesource.x86_64.rpm is not installed
nodejs-8.9.4-1nodesource.x86_64.rpm                                                                             |  17 MB  00:00:01     
Retrieving key from file:///etc/pki/rpm-gpg/NODESOURCE-GPG-SIGNING-KEY-EL
Importing GPG key 0x34FA74DD:
 Userid     : "NodeSource <gpg-rpm@nodesource.com>"
 Fingerprint: 2e55 207a 95d9 944b 0cc9 3261 5ddb e8d4 34fa 74dd
 Package    : nodesource-release-el7-1.noarch (installed)
 From       : /etc/pki/rpm-gpg/NODESOURCE-GPG-SIGNING-KEY-EL
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
Warning: RPMDB altered outside of yum.
  Installing : 2:nodejs-8.9.4-1nodesource.x86_64                                                                                   1/1 
  Verifying  : 2:nodejs-8.9.4-1nodesource.x86_64                                                                                   1/1 

Installed:
  nodejs.x86_64 2:8.9.4-1nodesource                                                                                                    

Complete!
[root@localhost oracle]# 
</code></pre>
    </li>
    <li>Use NPM to install the application and it's dependencies from GitHUB<br><br>
        <pre><code>$ mkdir NodeExample
$ cd NodeExample
$ npm install oracle-movie-ticket-demo
        </code></pre>
        <p>This should result in output similar to this (note your version numbers may be later that the ones shown below):</p>
        <pre><code>[oracle@localhost ~]$ mkdir NodeExample
[oracle@localhost ~]$ cd NodeExample/
[oracle@localhost NodeExample]$ npm install oracle-movie-ticket-demo
npm WARN saveError ENOENT: no such file or directory, open '/home/oracle/NodeExample/package.json'
npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN enoent ENOENT: no such file or directory, open '/home/oracle/NodeExample/package.json'
npm WARN NodeExample No description
npm WARN NodeExample No repository field.
npm WARN NodeExample No README data
npm WARN NodeExample No license field.

+ oracle-movie-ticket-demo@5.4.4
added 134 packages in 4.845s
[oracle@localhost NodeExample]$ 
</code></pre>
        <p>At this point the Node.js server has been installed and the application has been downloaded and is ready to run</p>
    </li>
</ol>
<h2>3. Install, configure and start Oracle Rest Data Services (ORDS)</h2>
<ol>
    <li>Download the latest version of <a href="http://www.oracle.com/technetwork/developer-tools/rest-data-services/downloads/index.html">ORDS</a> from the Oracle Technology Network website<br><br></li>
    <li>Install ORDS<br><br>
        <p>The following commands will work on Enterprise Linux, assuming the node installation zip file is in the users Downloads folder, for other environments please refer to the platform specific installation instructions at <a href="https://docs.oracle.com/cd/E37099_01/doc.20/e25066/toc.htm">https://docs.oracle.com/cd/E37099_01/doc.20/e25066/toc.htm</a>.</p>
        <pre><code>
            $ cd
            $ mkdir ORDS
            $ cd ORDS
            $ unzip ../Downloads/ords.3.0.5.124.10.54.zip 
        </code></pre>
        <p>Make sure that the database and listener are started and you know a TNS Alias that can connect to the database where ORDS will be installed. Then start the ORDS configuration process as shown below</p>
        <pre><code>$ java -jar ords.war
            This Oracle REST Data Services instance has not yet been configured.
            Please complete the following prompts
            Enter the location to store configuration data:/home/oracle/ORDS/config
            Enter the name of the database server [localhost]:
            Enter the database listen port [1521]:
            Enter 1 to specify the database service name, or 2 to specify the database SID [1]:1
            Enter the database service name:ORCL
            Enter the database password for ORDS_PUBLIC_USER:
            Confirm password:
            Please login with SYSDBA privileges to verify Oracle REST Data Services schema.
            Enter the username with SYSDBA privileges to verify the installation [SYS]:sys
            Enter the database password for sys:
            Confirm password:
            Oracle REST Data Services will be installed in ORCL
            Enter 1 if you want to use PL/SQL Gateway or 2 to skip this step.
            If using Oracle Application Express or migrating from mod_plsql then you must enter 1 [1]:2
        </code></pre>
        <p>At this point ORDS will be installed into the target database. The output will be as follows:</p>
        <pre><code>
            Jun 17, 2016 6:18:24 PM oracle.dbtools.common.config.file.ConfigurationFilesBase update
            INFO: Updated configurations: defaults, apex_pu
            Installing Oracle REST Data Services version 3.0.5.124.10.54
            ... Log file written to /home/oracle/ORDS/logs/ords_install_core_2016-06-17_181824_00306.log
            ... Verified database prerequisites
            ... Created Oracle REST Data Services schema
            ... Created Oracle REST Data Services proxy user
            ... Granted privileges to Oracle REST Data Services
            ... Created Oracle REST Data Services database objects
            Completed installation for Oracle REST Data Services version 3.0.5.124.10.54. Elapsed time: 00:00:14.299 
            Enter 1 if you wish to start in standalone mode or 2 to exit [1]:2
        </code></pre>
        </p>ORDS is now installed</P>
    </li>
    <li>Create an ORDS user that has permissions to use SODA for REST<br><br>
       <pre><code>
            java -jar ords.war user MovieTicketing "SODA Developer"
            Enter a password for user MovieTicketing: 
            Confirm password for user MovieTicketing: 
            Jun 17, 2016 6:29:33 PM oracle.dbtools.standalone.ModifyUser execute
            INFO: Created user: MovieTicketing in file: /home/oracle/ORDS/config/ords/credentials
        </code></pre>
     </li>
     <li>Increase the size of the ORDS JDBC connection pool<br><br>
         <p>Edit the file defaults.xml. Assuming you specified /home/oracle/ORDS/config when responding to the prompt "Enter the location to store configuration data:" in step 2.1 the file is located in the folder config/ords. Locate the entry with the key "jdbc.MaxLimit" and change the value to 500. Locate the entry with the key "jdbc.InitialLimit" and change the value to 50. Save the file</p>
     </li>
     <li>Start the ORDS Server<br><br>
        <p>The first time you start the ORDS server you are asked whether you want to use HTTP or HTTPS and to select the port the server is to listen on. This information is only required the first time ORDS is started.</p>
        <pre><code>
            [oracle@localhost ORDS]$ java -jar ords.war standalone
            Enter 1 if using HTTP or 2 if using HTTPS [1]:1
            Enter the HTTP port [8080]:
            2016-06-17 18:22:54.846:INFO::main: Logging initialized @5506ms
            Jun 17, 2016 6:22:55 PM oracle.dbtools.standalone.StandaloneJetty setupDocRoot
            INFO: Disabling document root because the specified folder does not exist: /home/oracle/ORDS/config/ords/standalone/doc_root
            2016-06-17 18:22:55.994:INFO:oejs.Server:main: jetty-9.2.z-SNAPSHOT
            Jun 17, 2016 6:22:56 PM oracle.dbtools.auth.crypto.CryptoKeysGenerator startup
            INFO: No encryption key found in configuration, generating key
            Jun 17, 2016 6:22:56 PM oracle.dbtools.auth.crypto.CryptoKeysGenerator startup
            INFO: No mac key found in configuration, generating key
            Jun 17, 2016 6:22:56 PM oracle.dbtools.common.config.file.ConfigurationFilesBase update
            INFO: Updated configurations: defaults
            Jun 17, 2016 6:22:56 PM oracle.dbtools.auth.crypto.CryptoKeysGenerator startup
            INFO: Updated configuration with generated keys
            2016-06-17 18:22:56.539:INFO:/ords:main: INFO: Using configuration folder: /home/oracle/ORDS/config/ords
            2016-06-17 18:22:56.539:INFO:/ords:main: FINEST: |ApplicationContext [configurationFolder=/home/oracle/ORDS/config/ords, services=Application Scope]|
            Jun 17, 2016 6:22:56 PM oracle.dbtools.common.config.db.DatabasePools validatePool
            INFO: Validating pool: |apex|pu|
            Jun 17, 2016 6:22:57 PM oracle.dbtools.common.config.db.DatabasePools validatePool
            INFO: Pool: |apex|pu| is correctly configured
            config.dir
            2016-06-17 18:22:57.381:INFO:/ords:main: INFO: Oracle REST Data Services initialized|Oracle REST Data Services version : 3.0.5.124.10.54|Oracle REST Data Services server info: jetty/9.2.z-SNAPSHOT|
            2016-06-17 18:22:57.384:INFO:oejsh.ContextHandler:main: Started o.e.j.s.ServletContextHandler@2d209079{/ords,null,AVAILABLE}
            2016-06-17 18:22:57.410:INFO:oejs.ServerConnector:main: Started ServerConnector@2c8d66b2{HTTP/1.1}{0.0.0.0:8080}
            2016-06-17 18:22:57.414:INFO:oejs.Server:main: Started @8085ms
            ^C2016-06-17 18:28:39.476:INFO:oejs.ServerConnector:Thread-1: Stopped ServerConnector@2c8d66b2{HTTP/1.1}{0.0.0.0:8080}
            2016-06-17 18:28:39.482:INFO:oejsh.ContextHandler:Thread-1: Stopped o.e.j.s.ServletContextHandler@2d209079{/ords,null,UNAVAILABLE}
        </code></pre>
        <p>At this point the ORDS server is running and ready to service SODA for REST operations</p>
     </li>
</ol>
<h2>4. Create the Database Schema that will manage the MovieTickets document collections</h2>
<ol>
    <li>Connect to the database and execute the following commands<br><br>
        <pre><code>
            $ sqlplus system@ORCL

            SQL*Plus: Release 12.1.0.2.0 Production on Fri Jun 17 19:01:37 2016
            Copyright (c) 1982, 2016, Oracle.  All rights reserved.
            
            Enter password: 
            Last Successful login time: Fri Jun 17 2016 18:14:03 -07:00

            Connected to:
            Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production

            SQL> grant connect, resource, unlimited tablespace, SODA_APP to MOVIES identified by MOVIES;

            Grant succeeded.

            SQL> connect MOVIES/MOVIES@ORCL
            Connected.
            SQL> begin
            2    ORDS.enable_schema();
            3    commit;
            4  end;
            5  /

            PL/SQL procedure successfully completed.

            SQL> quit
            Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production
        </code></pre>
        <p>The SODA_APP role is required to use Oracle Document Collections. The call to ORDS.enable_schema() is required to allow the schema to be accessed via ORDS. Both steps are required to use SODA for REST.</p>
     </li>
</ol>
<h2>5. Update configuration files.</h2>
<ol>
     <li>config.json<br><br>
         <p>The config.json file supplies the Node.js server with the information required to connect to the ORDS server. This file must be updated with the username and password and path to endpoint for the Movie Ticketing document store. Click the right arrow below to see a sample config.json document:</p>
         <div>
            <div id="sampleConfig"></div>
         </div>
         <br>
         <p>The file is located in the folder NodeExample/node_modules/oracle-movie-ticket-sample The keys in this file are self explanatory</p>
         <ul>
            <li><strong>hostname: </strong>The name or ipaddress of the machine hosting the ORDS instance</li>    
            <li><strong>port: </strong>The Port number the ORDS instance in listening on. This was specified the first time the ORDS instance was started (See step 3.4).</li>
            <li><strong>path: </strong>The endpoint that provides access to the Movie Ticketing document store. The second component of this path is the database schema name (See step 3.1). The schema name is entered lowercase.</li>
            <li><strong>username & password </strong>The user name and password used to authenticate with the ORDS server. Note this is the ORDS username and password from step 3.3, not the database schema name and password from step 4.1.<br><br></li>
         </ul>
     </li>
     <li>dataSources.json<br><br>
         <p>If the application needs use a proxy server to connect to these sites information about the proxy server must be added to the dataSources.json file.</p>
         <p>Click the right arrow below to see a sample dataSources.json document:</p>
          <div>
            <div id="sampleDataSources"></div>
          </div>
          <br>
          <p>The file is located in the folder NodeExample/node_modules/oracle-movie-ticket-sample. The following keys may need to be edited before running the application.</p>
          <ul>
            <li><strong>useProxy: </strong>Set to true if you need to use a proxy server to access external web sites.</li>    
            <li><strong>proxy.hostname: </strong>If a proxy server is required enter the hostname or ipaddress of the proxy server</li>
            <li><strong>proxy.port: </strong>If a proxy server is required enter the port number used to communicate with the proxy server</li>
            <li><strong>tmdb.searchCriteria:</strong>The application loads a small subset of the movies available on TMDb. Movies are selected based on a number of criteria, including release date and rating. To change which the movies selected update these fields before loading movie information.</li>
            <li><strong>fandango.searchCriteria.zipCode: </strong>The zip code to use when obtaining a list of nearby theaters from Fandango</li>
        </ul>   
    </li>
</ol>
<h2>6. Start the application servers</h2>
<ol>
    <li>Start Node.js server.<br><br>
        <p>The following commands will work on Enterprise Linux, assuming you followed the steps outlined above.</p>
        <pre><code>
            $ cd
            $ cd NodeExample/oracle-movie-ticket-demo
            $ node index.js
        </code></pre>
        <p>And the system should respond with something similar to this</p>
        <pre><code>
            2016-10-12T13:34:52.819Z: MovieTicket Webserver listening on localhost:3000
            2016-10-12T13:34:53.235Z: $contains operator supported:  true
            2016-10-12T13:34:53.235Z: $near operatator   supported:  true
        </code></pre>
      </li>
</ol>
<h2>7. Launch the application using a Browser.</h2>
<p></p>
<ol>
    <li>Navigate to the application start page. The application is configured to run on Port 3000.
        <br><br>
        <p>The first time you run the application you should see a page like this:</p>
        <img src="FirstStart.png" alt="First Time" style="width: 400px; height:  auto">
        <br><br>       
        <p>This page is used configure the application and obtain the data required to run the application.</p>
    </li>
    <li>Configure Application
       <br><br>
       <p>Movie Information is loaded using services provided by the website themoviedb.org. Theater information is obtained using an RSS feed published by Fandango.com.</p>
       <p>If the target document store supports Oracle Location services and the version of Query-By-Example included with SODA supports the  $near operator you are given option of geocoding the Theater information. Currently, only the US Government Census Bureau's Geocoding service and Google's Geocoding service are supported. If Geocoding is enabled you are given the option viewing theater locality graphically using a Mapping service. Currently only Google's Mapping service is supported. </p>
        <img src="EnterKeys.png" alt="Load Theaters and Movies" style="width: 400px; height:  auto">
        <br><br>       
        <p>If you want to make use of Geocoding and Mapping please select the required services using the provided menus. In order to load Movie Information a valid key for the TMDb API must be provided using the box marked TMDb API Key. In order to use Google services a valid key for relevant Google APIs must be provided using the box marked Google API. If you have not yet obtained the necessary API keys you can use the 'Get Key' buttons associated with each box to open the appropriate website used to request the necessary keys. Once your selections are made and the required keys have been entered click 'SAVE' to update dataSources.json. </p>
    </li>           
    <li>Load Theaters and Movies
        <br><br>
        <p>Successfully saving the configuration will enable the loading of Theaters and Movies.</p>
        <img src="LoadTestData.png" alt="Load Theaters and Movies" style="width: 400px; height:  auto">
        <br><br>       
        <p>Click the "Load" button associated with the Theaters collection to download theater information from Fandango. Click the "Load" button associated with the Movies collection to download movie information from TMDb. This operation may take a while to complete due to throughput restrictions imposed by the TMDb website. While the load operations are in progress the 'refresh' icon will rotate and the status box associated with target will display 'Working'. Once the load operations are completed the status box will be updated with the number of documents loaded. 
     </li>
    <li>Load Posters and Screenings 
        <br><br>
        <p>Successfully completing the "Load Movies" operation will enable the loading of Posters. Successfully completing the "Load Movies" and "Load Theaters" operations will enabled the generation of screenings.</p>
        <img src="LoadPostersScreenings.png" alt="Load Posters and Screenings" style="width: 400px; height:  auto">
        <br><br>       
        <p>Click the "Load" button associated with the Posters collection to download movie posters from TMDb. This operation is also subject to the throughput restrictions imposed by the TMDb website. Click the "Load" button associated with the Screenings collection to generate 2 weeks' worth of screenings from the current set of theaters and movies. While the load and generate operations are is in progress the 'refresh' icon will rotate and the status box associated with target will display 'Working'. Once the load and gemerate operations are completed the status box will be updated with the number of documents loaded.</p>
        <p>The data loading process only needs to be completed once, since once data loading is completed all of the information needed to run the application is stored as JSON documents in the Oracle document store. If any of the steps fail, simply click the associated button to try the step again. Note you must successfully complete "Load Movies" before attempting to run "Load Posters", and you must successfully complete "Load Theaters" and "Load Movies" before attempting to run "Generate Screenings". If you re-run either "Load Theaters" or "Load Movies" you must re-run "Generate Screenings before attempting to use the movie ticketing application. If you re-run "Load Movies" you must also re-run "Load Posters" to repopulate the Posters collection.</p>

    <li>Run the Application
        <br><br>
        <p>Once the Posters have been loaded and the Screenings generated the application will automatically reload itself and the "List Theaters" and "List Movies" tabs will be displayed. The applicaiton is now ready for use.</p>
        <img src="TestData-Completed.png" alt="Completed" style="width: 400px; height:  auto">
    </li>
</ol>
<script type="text/javascript" lang="javascript" src="jsonViewer.js"></script>
<script type="text/javascript" lang="javascript" src="sampleDocuments.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
<script lang="javascript">hljs.initHighlightingOnLoad();</script>
</body>
</html>
